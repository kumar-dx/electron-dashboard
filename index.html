<!DOCTYPE html>
<html>
<head>
    <title>RTSP Stream Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .controls {
            margin-bottom: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        input[type="text"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        #toggleBtn {
            background-color: #4CAF50;
            color: white;
            width: 120px;
        }
        #toggleBtn.stop {
            background-color: #f44336;
        }
        .stream-container {
            background-color: black;
            padding: 10px;
            border-radius: 8px;
            margin-top: 20px;
            min-height: 480px;
            position: relative;
        }
        #streamCanvas {
            width: 100%;
            max-width: 1280px;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: #e8e8e8;
        }
        .error {
            color: #f44336;
            font-weight: bold;
        }
        .info {
            margin-top: 10px;
            padding: 10px;
            background-color: #e8f5e9;
            border-radius: 4px;
            font-size: 14px;
        }
        .info code {
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <input type="text" id="rtspUrl" placeholder="Enter RTSP URL (e.g., rtsp://username:password@ip:port/stream)">
            <button id="toggleBtn">Start Stream</button>
        </div>
        <div class="stream-container">
            <canvas id="streamCanvas" width="1280" height="720"></canvas>
        </div>
        <div class="status" id="status">Status: Stopped</div>
        <div class="info" id="imagesDirInfo">Images are saved in: <code>Loading...</code></div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        const toggleBtn = document.getElementById('toggleBtn');
        const rtspUrl = document.getElementById('rtspUrl');
        const status = document.getElementById('status');
        const canvas = document.getElementById('streamCanvas');
        const imagesDirInfo = document.getElementById('imagesDirInfo');
        const ctx = canvas.getContext('2d');
        let ws;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        let isStreaming = false;
        let intentionalStop = false;
        
        // Add buffer for accumulating chunks
        let frameBuffer = [];
        let frameSize = 0;
        let isFrameStart = false;

        // Function to check for JPEG markers
        function findJPEGMarkers(data) {
            // Look for JPEG start marker (FFD8)
            for (let i = 0; i < data.length - 1; i++) {
                if (data[i] === 0xFF && data[i + 1] === 0xD8) {
                    return { start: i, isStart: true };
                }
                if (data[i] === 0xFF && data[i + 1] === 0xD9) {
                    return { start: i, isStart: false };
                }
            }
            return null;
        }

        // Function to process a complete frame
        function processFrame(frameData) {
            try {
                // Verify this is a valid JPEG (starts with FFD8 and ends with FFD9)
                if (frameData.length < 4 || 
                    frameData[0] !== 0xFF || frameData[1] !== 0xD8 ||
                    frameData[frameData.length - 2] !== 0xFF || frameData[frameData.length - 1] !== 0xD9) {
                    console.log('Invalid JPEG frame detected, skipping...');
                    return;
                }

                console.log('Processing frame of size:', frameData.length);
                
                // Convert to base64
                const base64String = btoa(String.fromCharCode.apply(null, frameData));
                const dataUrl = `data:image/jpeg;base64,${base64String}`;
                
                // Create new image and set source
                const image = new Image();
                
                // Set up onload before setting src
                image.onload = () => {
                    try {
                        console.log('Image loaded successfully:', image.width, 'x', image.height);
                        // Clear previous frame
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw new frame
                        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                        status.textContent = 'Status: Streaming';
                        status.className = 'status';
                    } catch (drawError) {
                        console.error('Error drawing image:', drawError);
                        status.textContent = 'Status: Error drawing image';
                        status.className = 'status error';
                    }
                };
                
                // Set up onerror before setting src
                image.onerror = (err) => {
                    console.error('Error loading image:', {
                        error: err,
                        frameSize: frameData.length,
                        startBytes: Array.from(frameData.slice(0, 4)).map(b => b.toString(16)).join(' '),
                        endBytes: Array.from(frameData.slice(-4)).map(b => b.toString(16)).join(' ')
                    });
                    status.textContent = 'Status: Error loading image frame';
                    status.className = 'status error';
                };
                
                // Set the image source
                image.src = dataUrl;
            } catch (error) {
                console.error('Error processing complete frame:', error);
                status.textContent = 'Status: Error processing frame';
                status.className = 'status error';
            }
        }

        // Get and display the images directory path
        (async () => {
            try {
                const imagesDir = await ipcRenderer.invoke('get-images-dir');
                imagesDirInfo.innerHTML = `Images are saved in: <code>${imagesDir}</code>`;
            } catch (error) {
                console.error('Error getting images directory:', error);
            }
        })();

        toggleBtn.addEventListener('click', () => {
            if (!isStreaming) {
                if (!rtspUrl.value) {
                    alert('Please enter an RTSP URL');
                    return;
                }
                // Start streaming
                status.textContent = 'Status: Starting...';
                status.className = 'status';
                reconnectAttempts = 0;
                ipcRenderer.send('start-stream', rtspUrl.value);
                connectWebSocket();
                toggleBtn.textContent = 'Stop Stream';
                toggleBtn.classList.add('stop');
                isStreaming = true;
            } else {
                // Stop streaming
                ipcRenderer.send('stop-stream');
                closeWebSocket();
                status.textContent = 'Status: Stopped';
                status.className = 'status';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                toggleBtn.textContent = 'Start Stream';
                toggleBtn.classList.remove('stop');
                isStreaming = false;
            }
        });

        function closeWebSocket() {
            if (ws) {
                intentionalStop = true;
                ws.close();
                ws = null;
            }
        }

        function connectWebSocket() {
            intentionalStop = false;
            closeWebSocket();

            console.log('Connecting to WebSocket...');
            // Use localhost for Electron environment
            ws = new WebSocket('ws://localhost:9999');
            
            // Set binary type to arraybuffer
            ws.binaryType = 'arraybuffer';
            
            ws.onopen = () => {
                console.log('WebSocket connected');
                status.textContent = 'Status: Connected';
                status.className = 'status';
                reconnectAttempts = 0;
            };

            ws.onmessage = async (msg) => {
                try {
                    // Convert ArrayBuffer to Uint8Array
                    const chunk = new Uint8Array(msg.data);
                    
                    // Debug the actual bytes we're receiving
                    const byteString = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ');
                    console.log('Received bytes:', byteString);
                    
                    // If chunk is small, accumulate in buffer until we have enough data
                    if (chunk.length < 100) { // Small chunk threshold
                        frameBuffer.push(chunk);
                        frameSize += chunk.length;
                        
                        // Try to process accumulated data
                        if (frameSize > 0) {
                            const combinedChunk = new Uint8Array(frameSize);
                            let offset = 0;
                            for (const buf of frameBuffer) {
                                combinedChunk.set(buf, offset);
                                offset += buf.length;
                            }
                            
                            // Look for JPEG markers in combined data
                            const markerInfo = findJPEGMarkers(combinedChunk);
                            if (markerInfo) {
                                console.log('Found marker in combined data:', 
                                    markerInfo.isStart ? 'START' : 'END',
                                    'at position', markerInfo.start);
                            }
                        }
                    } else {
                        // Large chunk - process as before
                        const markerInfo = findJPEGMarkers(chunk);
                        
                        if (markerInfo) {
                            if (markerInfo.isStart) {
                                console.log('Found start of new JPEG frame at position:', markerInfo.start);
                                frameBuffer = [chunk.slice(markerInfo.start)];
                                frameSize = chunk.length - markerInfo.start;
                                isFrameStart = true;
                            } else if (isFrameStart) {
                                console.log('Found end of JPEG frame at position:', markerInfo.start);
                                frameBuffer.push(chunk.slice(0, markerInfo.start + 2));
                                frameSize += markerInfo.start + 2;
                                
                                // Combine all chunks
                                const combinedFrame = new Uint8Array(frameSize);
                                let offset = 0;
                                for (const chunk of frameBuffer) {
                                    combinedFrame.set(chunk, offset);
                                    offset += chunk.length;
                                }
                                
                                // Process the complete frame
                                processFrame(combinedFrame);
                                
                                // Reset for next frame
                                frameBuffer = [];
                                frameSize = 0;
                                isFrameStart = false;
                                
                                // If there's more data after this frame, start a new frame
                                if (markerInfo.start + 2 < chunk.length) {
                                    const remainingData = chunk.slice(markerInfo.start + 2);
                                    frameBuffer.push(remainingData);
                                    frameSize = remainingData.length;
                                }
                            }
                        } else if (isFrameStart) {
                            // Middle of frame, add to buffer
                            frameBuffer.push(chunk);
                            frameSize += chunk.length;
                        }
                    }
                    
                } catch (error) {
                    console.error('Error processing stream data:', error);
                    status.textContent = 'Status: Error processing stream data';
                    status.className = 'status error';
                    // Reset buffer on error
                    frameBuffer = [];
                    frameSize = 0;
                    isFrameStart = false;
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket Error:', error);
                status.textContent = 'Status: Connection Error';
                status.className = 'status error';
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
                status.textContent = 'Status: Disconnected';
                
                // Attempt to reconnect only if not intentionally stopped
                if (!intentionalStop && reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    console.log(`Reconnecting... Attempt ${reconnectAttempts}`);
                    setTimeout(connectWebSocket, 2000);
                } else {
                    if (!intentionalStop) {
                        status.textContent = 'Status: Failed to connect';
                        status.className = 'status error';
                    }
                }
            };
        }

        ipcRenderer.on('stream-started', () => {
            console.log('Stream started from main process');
            isStreaming = true;
            toggleBtn.textContent = 'Stop Stream';
            toggleBtn.classList.add('stop');
        });

        ipcRenderer.on('stream-stopped', () => {
            closeWebSocket();
            status.textContent = 'Status: Stopped';
            status.className = 'status';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            isStreaming = false;
            toggleBtn.textContent = 'Start Stream';
            toggleBtn.classList.remove('stop');
        });

        ipcRenderer.on('stream-error', (event, error) => {
            console.error('Stream error from main process:', error);
            status.textContent = `Status: Error - ${error}`;
            status.className = 'status error';
            isStreaming = false;
            toggleBtn.textContent = 'Start Stream';
            toggleBtn.classList.remove('stop');
        });

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            closeWebSocket();
        });
    </script>
</body>
</html> 